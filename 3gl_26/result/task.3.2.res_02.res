#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <ctype.h>\n\n#include "log.h"\n#include "common.h"\n#include "checker.h"\n\n// to common.h\nstatic inline void                    fprintn(FILE *f, const char *str, int sz){\n    char c;\n    int i = 0;\n    while (str && i < sz &&(c = str[i++]) != '\0')\n        fputc(c, f);\n    fputc('\n', f);\n}\n\nstatic inline void                    printn(const char *str, int sz){\n    return fprintn(stdout, str, sz);\n}\n\n// internal proc\nstatic int              escape(char *restrict t, const char *restrict s, int sz);\n\nstatic int              unescape(char *restrict t, const char *restrict s, int sz);\n\nconst char *usage_str = "Usage: E(espace)/U(unescape) %s\n";\n\nint                     main(int argc, const char *argv[]){\n\n    static const char *logfilename = "log/escape.3.2.log";\n    loginit(logfilename, false, 0, "Start");    // TODO: rework that to LOG("logdir") or LOGAPPEND("logdir") or LOGSWITCH("logdir")\n\n    if (argc > 1){\n        if (strcmp(argv[1], "-v") == 0 || strcmp(argv[1], "--version") == 0){\n            printf("%s secape KR task 3.2\n", __FILE__);\n            printf(usage_str, *argv);\n            return 0;\n        }\n    }\n    if (!check_arg(2, usage_str, *argv) ){\n        return 4;\n    }\n\n    int     sz;\n    char    op = toupper(*argv[1]);\n\n    if (!inv(op == 'E' || op == 'U', "oper type is unexpected") )\n        return 4;\n\n    const char *s = read_from_file(stdin, &sz);\n    if (!s){\n        fprintf(stderr, "Unable to read from stdin\n");\n        return 1;\n    }\n    //printf("%s", s);\n\n    char *t = malloc(sz * 2 + 1);\n    if (!t){\n        fprintf(stderr, "Unable  to allocate %d\n", sz + 1);\n        return 2;\n    }\n    if (op == 'E')\n        escape(t, s, sz * 2);\n    else\n        unescape(t, s, sz);\n\n    printf("%s", t);    // not sure\n\n    free((char *) s), free(t);\n\n    logclose("...");\n    return 0;\n}\n\nstatic int              escape(char *restrict t, const char *restrict s, int sz){\n    logenter("sz %d", sz);\n    fprintn(logfile, s, 10);\n    int     i = 0, j = 0;\n    char    c;\n    while (j < sz - 1 && ( (c = s[i++]) != '\0') ){   // - 1 because of escape (2 chars)\n        if (j % 100 == 0)\n            logmsg("j %d, c [%c], i %d", j, c, i);\n        switch(c){\n            case '\n':\n                t[j++] = '\\';\n                t[j++] = 'n';\n            break;\n            case '\t':\n                t[j++] = '\\';\n                t[j++] = 't';\n            break;\n            default:\n                t[j++] = c;\n            break;\n        }\n    }\n    logmsg("j=%d, i=%d, sz - 1 = %d c = [%c]", j, i, sz - 1, c);\n    // check if last sym '/'\n    if (j == sz - 1 && (c != '\\' && c != '\0') )\n        t[j++] = c;\n    t[j] = '\0';\n    return logret(j, "ret sz %d", j);\n}\n\nstatic int              unescape(char *restrict t, const char *restrict s, int sz){\n    int     i = 0, j = 0;\n    char    c, c1;\n    while (j < sz && (c = s[i++] != '\0') ){\n        switch (c){\n            case '\\':\n                c1 = s[i++];\n                switch (c1){\n                    case 'n':\n                        t[j++] = '\n';\n                    break;\n                    case 't':\n                        t[j++] = '\t';\n                    break;\n                    default:\n                        t[j++] = '\\';\n                        i--;\n                    break;\n                }\n            break;\n            default:\n                t[j++] = c;\n            break;\n        }\n    }\n    t[j] = '\0';\n    return j;\n}\n\n